When building distributed services, you’re communicating between the services
over a network. To send data (such as your structs) over a network, you need
to encode the data in a format to transmit, and lots of programmers choose
JSON. When you’re building public APIs or you’re creating a project where
you don’t control the clients, JSON makes sense because it’s accessible—both
for humans to read and computers to parse. But when you’re building private
APIs or building projects where you do control the clients, you can make use
of a mechanism for structuring and transmitting data that—compared to
JSON—makes you more productive and helps you create services that are
faster, have more features, and have fewer bugs.

So what is this mechanism? Protocol buffers (also known as protobuf), which
is Google’s language and platform-neutral extensible mechanism for structuring and serializing data. The advantages of using protobuf are that it:
• Guarantees type-safety;
• Prevents schema-violations;
• Enables fast serialization; and
• Offers backward compatibility

Here’s a quick example that shows what protocol buffers look like and how
they work. Imagine you work at Twitter and one of the object types you work
with are Tweets. Tweets, at the very least, comprise the author’s message. If
you defined this in protobuf, it would look like this:

example.proto
syntax = "proto3";
package twitter;
message Tweet {
string message = 1;
}

You’d then compile this protobuf into code in the language of your choice.
For example, the protobuf compiler would take this protobuf and generate
the following Go code:

compile it to any lanuage e.g go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: example.proto
package twitter
type Tweet struct {
Message string `protobuf:"bytes,1,opt,name=message,proto3"
json:"message,omitempty"`
// Note: Protobuf generates internal fields and methods
// I haven't included for brevity.
}

gRPC uses protocol buffers to define APIs and serialize messages; we’ll use
gRPC to build our client and server.
Let’s get you set up to create your own protobuf
and use it to build stuff.


Install the Protocol Buffer Compiler
Go to the Protobuf release page on GitHub2
 and
download the relevant release for your computer

You can download and install
in your terminal like so:
$ wget https://github.com/protocolbuffers/protobuf/\
releases/download/v3.9.0/protoc-3.9.0-osx-x86_64.zip
$ unzip protoc-3.9.0-osx-x86_64.zip -d /usr/local/protobuf

Here’s what the layout and files in the extracted protobuf directory look like:
❯ tree /usr/local/protobuf
As you can see, a protobuf installation consists of two directories. The bin
directory contains the compiler binary named protoc, and the include directories
contains a bunch of protobuf files that are like protobuf’s standard library.
so just extract the whole release using the commands I just showed you

Now that you’ve got the compiler binary installed, make sure your shell can
find and run it
. Add the binary to your PATH env var using your shell’s configuration file. If you’re using ZSH for instance, run something like the following to update your configuration:
$ echo 'export PATH="$PATH:/usr/local/protobuf/bin"' >> ~/.zshenv
To test the installation, run protoc --version.

Define Your Domain Types as Protocol Buffers

At the beginning of this section, I had you put the log.proto file into an api/v1
directory. The v1 represents these protobufs’ major version.
To compile protobuf into the code of some programming language, you need
the runtime for that language. The compiler itself doesn’t know how to compile
protobuf into every language—it needs a language-specific runtime to do so

Go has two runtimes to compile protobuf into Go code. The Go team and the
protobuf team at Google developed the original runtime.4
 Then a team of folks
who wanted more features forked the original runtime and developed it into
gogoprotobuf, with more code-generation features and faster marshaling and
unmarshaling. Projects like Etcd, Mesos, Kubernetes, Docker, CockroachDB,
and NATS as well as companies like Dropbox and Sendgrid used gogoprotobuf.
I used gogoprotobuf for my projects to integrate with Kubernetes’ protocol
buffers and for gogoprotobuf’s features.
To compile our protobuf into Go, we need to install the protobuf runtime by
running the following command:
$ go get google.golang.org/protobuf/...@v1.25.0

You can now compile your protobuf by running the following command at
the root of your project:
// $ protoc api/v1/*.proto \
// --go_out=. \
// --go_opt=paths=source_relative \
// --proto_path=.
Look in the api/v1 directory and you’ll see a new file called log.pb.go.
Your
protobuf message has been turned into a Go struct, along with some methods
on the struct for marshaling to the protobuf binary wire format, and getters
for your fields.
Since you’ll compile your protobuf every time you change them, it’s worth
adding a Makefile file with a compile target that you can quickly run again
and again. 
// makefile
The compiler generates various methods on the struct, but the only methods
you’ll use directly are the getters. Use the struct’s fields when you can, but
you’ll find the getters useful when you have multiple messages with the same
getter(s) and you want to abstract those method(s) into an interface.

































